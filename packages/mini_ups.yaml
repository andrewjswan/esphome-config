substitutions:
  vcc_empty: "12.0"
  vcc_full: "16.5"
  vcc_critical_low: "12.3"
  vcc_critical_high: "16.3"
  vcc_plugged: "17.0"
  charge_speed: "0.5"
  project_name: "chertvl_|_ajs.Mini_(DC)_UPS"
  project_version: "1.0.5"
  ADC: GPIO36

  vcc_calibration1: "11.0 -> 12.0"
  vcc_calibration2: "16.3 -> 16.5"

globals:
  - id: message_send
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: charger_last_event
    type: time_t
    restore_value: yes
    initial_value: '0'
  - id: dod
    type: float
    restore_value: yes
    initial_value: '${vcc_full}'

esphome:
  on_boot:
    then:
      - binary_sensor.template.publish:
          id: undercharge
          state: OFF

binary_sensor:
  - platform: template
    name: Power supply
    id: plugged
    device_class: plug
    lambda: |-
      if (id(vcc).has_state()) {
        return (id(vcc).state >= ${vcc_plugged});
      }
      return {};
    on_press:
      then:
        - globals.set:
            id: charger_last_event
            value: !lambda |-
              auto time = id(esp_time).now();
              if (!time.is_valid()) {
                return (time_t)0;
              }
              return (time_t)time.timestamp;
        - globals.set:
            id: message_send
            value: 'false'
        - binary_sensor.template.publish:
            id: undercharge
            state: OFF
    on_release:
      then:
        - globals.set:
            id: charger_last_event
            value: !lambda |-
              auto time = id(esp_time).now();
              if (!time.is_valid()) {
                return (time_t)0;
              }
              return (time_t)time.timestamp;
        - globals.set:
            id: dod
            value: !lambda |-
              return id(vcc).state;
        - if:
            condition:
              lambda: 'return id(vcc).state <= ${vcc_critical_high};'
            then:
              - binary_sensor.template.publish:
                  id: undercharge
                  state: ON
    web_server:
      sorting_weight: 10

  - platform: template
    name: Critical
    id: critical
    device_class: problem
    lambda: |-
      if (id(vcc).has_state()) {
        return (id(vcc).state <= ${vcc_critical_low});
      }
      return {};
    web_server:
      sorting_weight: 15

  - platform: template
    name: Undercharge
    id: undercharge
    device_class: problem
    web_server:
      sorting_weight: 20

sensor:
  - platform: template
    name: Battery
    id: battery
    unit_of_measurement: '%'
    device_class: battery
    state_class: measurement
    # entity_category: diagnostic
    accuracy_decimals: 0
    web_server:
      sorting_weight: 5

  - platform: adc
    pin: ${ADC}
    name: Voltage
    id: vcc
    attenuation: 12db
    update_interval: 2s
    accuracy_decimals: 1
    icon: mdi:flash-outline
    device_class: voltage
    state_class: measurement
    entity_category: diagnostic
    filters:
      - multiply: 11.0
      - calibrate_linear:
          - ${vcc_calibration1}
          - ${vcc_calibration2}
      - median:
          window_size: 15
          send_every: 1
      - or:
          - throttle: 180s
          - delta: 0.1
    on_value:
      then:
        - sensor.template.publish:
            id: battery
            state: !lambda |-
              return std::clamp(remap((float)x, (float)${vcc_empty}, (float)${vcc_full}, 0, 100), 0, 100);
        - if:
            condition:
              and:
                - lambda: 'return !id(plugged);'
            then:
              - globals.set:
                  id: dod
                  value: !lambda |-
                    return (float)x;
    on_value_range:
      below: ${vcc_critical_low}
      then:
        - logger.log:
            format: "Low power (%.1fV), Battery: %d%%..."
            level: "WARN"
            tag: "power"
            args: ['id(vcc).state', 'id(battery).state']
        - if:
            condition:
              and:
                - wifi.connected:
                - lambda: 'return !id(message_send);'
            then:
              - script.execute:
                  id: send_telegram_message
                  message: !lambda |-
                    return id(swatch_time).state + " ðŸš¨ *${friendly_name}:*\n" +
                                                   "Battery empty!\n" +
                                                   "âš¡ VCC " + value_accuracy_to_string(id(vcc).state, 1) + "V\n" +
                                                   "ðŸ”‹ Battery " + value_accuracy_to_string(id(battery).state, 0) + "% ";
                  silent: false
              - globals.set:
                  id: message_send
                  value: 'true'
    disabled_by_default: true
    web_server:
      sorting_weight: 5

  - platform: template
    name: Remaining
    id: remaining
    accuracy_decimals: 0
    unit_of_measurement: "min"
    icon: mdi:battery-clock-outline
    update_interval: ${update_interval}
    device_class: duration
    state_class: measurement
    entity_category: diagnostic
    lambda: |-
      if (id(charger_last_event) == 0 || !id(vcc).has_state() || !id(esp_time).now().is_valid()) {
        return {};
      }

      float used_voltage = ${vcc_full} - id(vcc).state;
      if (id(plugged).state || used_voltage <= 0.01) {
        return {INFINITY};
      }

      time_t elapsed_seconds = id(esp_time).now().timestamp - id(charger_last_event);
      if (elapsed_seconds <= 0) {
          return {};
      }
      float rate = used_voltage / (float)elapsed_seconds;

      uint32_t remaining_seconds = (uint32_t)(id(vcc).state / rate);
      return { remaining_seconds / 60.0f };
    disabled_by_default: true
    web_server:
      sorting_weight: 10

  - platform: template
    name: Charger Last Event
    icon: mdi:power
    update_interval: ${update_interval}
    device_class: timestamp
    entity_category: diagnostic
    lambda: |-
      if (id(charger_last_event) == 0) {
        return NAN;
      }
      return id(charger_last_event);
    disabled_by_default: true
    web_server:
      sorting_weight: 30

  - platform: template
    name: Depth of Discharge
    accuracy_decimals: 1
    icon: mdi:battery-arrow-down-outline
    update_interval: ${update_interval}
    device_class: voltage
    state_class: measurement
    entity_category: diagnostic
    lambda: |-
      return { id(dod) };
    disabled_by_default: true
    web_server:
      sorting_weight: 100

  - platform: template
    name: Charging ETA
    accuracy_decimals: 1
    unit_of_measurement: "h"
    icon: "mdi:timer-sand"
    update_interval: ${update_interval}
    device_class: duration
    state_class: measurement
    entity_category: diagnostic
    lambda: |-
      float current_v = id(dod);
      float full_v = ${vcc_full};
      float charge_speed = ${charge_speed};

      if (current_v >= full_v) {
        return 0.0;
      } else if (current_v < 1.0) { 
        return NAN;
      }
      return (full_v - current_v) / charge_speed;
    disabled_by_default: true
    web_server:
      sorting_weight: 150

text_sensor:
  # Swatch Time
  - !include ../common/text_sensor/swatch_time.yaml

  - platform: template
    name: Remaining Time
    id: remaining_time
    icon: mdi:battery-clock-outline
    update_interval: ${update_interval}
    entity_category: diagnostic
    lambda: |-
      if (id(plugged).state) {
        return {"Plugged"};
      }

      if (id(charger_last_event) == 0 || !id(vcc).has_state() || !id(esp_time).now().is_valid()) {
        return {"Calibration"};
      }

      if (id(vcc).state < 5.0) {
        return {"Disconnected"};
      }

      float used_voltage = ${vcc_full} - id(vcc).state;
      if (used_voltage <= 0.01) {
        return {"âˆž"};
      }

      time_t elapsed_seconds = id(esp_time).now().timestamp - id(charger_last_event);
      if (elapsed_seconds <= 0) {
        return {"Calibration"};
      }

      float rate = used_voltage / (float)elapsed_seconds;
      uint32_t remain_seconds = (uint32_t)(id(vcc).state / rate);

      uint8_t minutes = (uint8_t)((remain_seconds % 3600) / 60);
      uint8_t hours = (uint8_t)((remain_seconds % 86400) / 3600);
      uint8_t days = (uint8_t)(remain_seconds / 86400);

      char buffer[32];
      if (days > 0) {
        snprintf(buffer, sizeof(buffer), "%dd %dhr %dmin", days, hours, minutes);
      } else if (hours > 0) {
        snprintf(buffer, sizeof(buffer), "%dhr %dmin", hours, minutes);
      } else if (minutes > 0) {
        snprintf(buffer, sizeof(buffer), "%dmin", minutes);
      } else {
        snprintf(buffer, sizeof(buffer), "Less than a minute");
      }

      return { std::string(buffer) };
    disabled_by_default: true
    web_server:
      sorting_weight: 15
