substitutions:
  vcc_empty: "12.0"
  vcc_full: "16.5"
  vcc_critical: "12.1"
  vcc_plugged: "17.0"
  project_name: "chertvl|ajs.DC_UPS"
  project_version: "1.0.1"
  ADC: GPIO36

  vcc_calibration1: "11.0 -> 12.0"
  vcc_calibration2: "16.3 -> 16.5"

globals:
  - id: message_send
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: discharge_time
    type: time_t
    restore_value: yes
    initial_value: '0'

binary_sensor:
  - platform: template
    name: Power supply
    id: plugged
    device_class: plug
    lambda: |-
      if (id(vcc).has_state()) {
        return (id(vcc).state >= ${vcc_plugged});
      }
      return {};
    on_press:
      then:
        - globals.set:
            id: message_send
            value: 'false'
    on_release:
      then:
        - globals.set:
            id: discharge_time
            value: !lambda |-
              auto time = id(esp_time).now();
              if (!time.is_valid()) {
                return (time_t)0;
              }
              return (time_t)time.timestamp;

  - platform: template
    name: Critical
    id: critical
    device_class: problem
    lambda: |-
      if (id(vcc).has_state()) {
        return (id(vcc).state <= ${vcc_critical});
      }
      return {};

sensor:
  - platform: template
    name: Battery
    id: battery
    unit_of_measurement: '%'
    device_class: battery
    state_class: measurement
    # entity_category: diagnostic
    accuracy_decimals: 0

  - platform: adc
    pin: ${ADC}
    name: Voltage
    id: vcc
    attenuation: 12db
    update_interval: 2s
    accuracy_decimals: 1
    icon: mdi:flash-outline
    device_class: voltage
    state_class: measurement
    entity_category: diagnostic
    filters:
      - multiply: 11.0
      - calibrate_linear:
          - ${vcc_calibration1}
          - ${vcc_calibration2}
      - median:
          window_size: 15
          send_every: 1
      - or:
          - throttle: 180s
          - delta: 0.1
    on_value:
      then:
        - sensor.template.publish:
            id: battery
            state: !lambda |-
              return std::clamp(remap((float)x, (float)${vcc_empty}, (float)${vcc_full}, 0, 100), 0, 100);
    on_value_range:
      below: ${vcc_critical}
      then:
        - logger.log:
            format: "Low power (%.1fV), Battery: %d%%..."
            level: "WARN"
            tag: "power"
            args: ['id(vcc).state', 'id(battery).state']
        - if:
            condition:
              and:
                - wifi.connected:
                - lambda: 'return !id(message_send);'
            then:
              - script.execute:
                  id: send_telegram_message
                  message: !lambda |-
                    return id(swatch_time).state + " 🚨 *${friendly_name}:*\n" +
                                                   "Battery empty!\n" +
                                                   "⚡ VCC " + value_accuracy_to_string(id(vcc).state, 1) + "V\n" +
                                                   "🔋 Battery " + value_accuracy_to_string(id(battery).state, 0) + "% ";
                  silent: false
              - globals.set:
                  id: message_send
                  value: 'true'
    disabled_by_default: true

  - platform: template
    name: Remaining
    id: remaining
    accuracy_decimals: 0
    unit_of_measurement: "min"
    icon: mdi:battery-clock-outline
    update_interval: ${update_interval}
    device_class: duration
    state_class: measurement
    entity_category: diagnostic
    lambda: |-
      if (id(discharge_time) == 0 || !id(vcc).has_state() || !id(esp_time).now().is_valid()) {
        return {};
      }

      float used_voltage = ${vcc_full} - id(vcc).state;
      if (id(plugged).state || used_voltage <= 0.01) {
        return {INFINITY};
      }

      time_t elapsed_seconds = id(esp_time).now().timestamp - id(discharge_time);
      if (elapsed_seconds <= 0) {
          return {};
      }
      float rate = used_voltage / (float)elapsed_seconds;

      uint32_t remaining_seconds = (uint32_t)(id(vcc).state / rate);
      return { remaining_seconds / 60.0f };
    disabled_by_default: true

text_sensor:
  # Swatch Time
  - !include ../common/text_sensor/swatch_time.yaml

  - platform: template
    name: Remaining Time
    id: remaining_time
    icon: mdi:battery-clock-outline
    update_interval: ${update_interval}
    entity_category: diagnostic
    lambda: |-
      if (id(plugged).state) {
        return {"Plugged"};
      }

      if (id(discharge_time) == 0 || !id(vcc).has_state() || !id(esp_time).now().is_valid()) {
        return {"Calibration"};
      }

      if (id(vcc).state < 5.0) {
        return {"Disconnected"};
      }

      float used_voltage = ${vcc_full} - id(vcc).state;
      if (used_voltage <= 0.01) {
        return {"∞"};
      }

      time_t elapsed_seconds = id(esp_time).now().timestamp - id(discharge_time);
      if (elapsed_seconds <= 0) {
        return {"Calibration"};
      }

      float rate = used_voltage / (float)elapsed_seconds;
      uint32_t remain_seconds = (uint32_t)(id(vcc).state / rate);

      uint8_t minutes = (uint8_t)((remain_seconds % 3600) / 60);
      uint8_t hours = (uint8_t)((remain_seconds % 86400) / 3600);
      uint8_t days = (uint8_t)(remain_seconds / 86400);

      char buffer[32];
      if (days > 0) {
        snprintf(buffer, sizeof(buffer), "%dd %dhr %dmin", days, hours, minutes);
      } else if (hours > 0) {
        snprintf(buffer, sizeof(buffer), "%dhr %dmin", hours, minutes);
      } else if (minutes > 0) {
        snprintf(buffer, sizeof(buffer), "%dmin", minutes);
      } else {
        snprintf(buffer, sizeof(buffer), "Less than a minute");
      }

      return { std::string(buffer) };
    disabled_by_default: true
